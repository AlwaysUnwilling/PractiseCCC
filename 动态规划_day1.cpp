#include<iostream>

//动态规划具备了以下三个特点
//1. 把原来的问题分解成了几个相似的子问题。
//2. 所有的子问题都只需要解决一次。
//3. 储存子问题的解。
//动态规划问题一般从以下四个角度考虑：
//1. 状态定义
//2. 状态间的转移方程定义
//3. 状态的初始化
//4. 返回结果
//状态定义的要求：定义的状态一定要形成递推关系。
//一句话概括：三特点四要素两本质
//适用场景：最大值 / 最小值, 可不可行, 是不是，方案个数

//题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//动态规划：
// 状态：
// 子状态：跳上1级，2级，3级...，n级台阶的跳法数
// f(n):最后一次的跳法总和---最后一步跳一个台阶和最后一步跳2个台阶的方法总和
// 
// 状态递推：
// n级台阶，最后一步剩一个台阶或2个台阶
// f(n)=f(n-1)+f(n-2)
// f(n-1)=f(n-2)+f(n-3)
// f(n-2)=f(n-3)+f(n-4)
// ...
// f(3)=f(2)+f(1);
//初始值：
//f(1)=1;f(2)=2;

class Solution {
public:
    int jumpFloor(int number) {
        if (number == 1 || number == 2) {
            return number;
        }
        int f1 = 1;
        int f2 = 2;
        int f3 = 0;
        for (size_t i = 3; i <= number; ++i) {
            f3 = f2 + f1;
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }
};

//题目描述:一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多
//少种跳法。
//动态规划:
//状态：
//子状态：跳上1级，2级，3级，...，n级台阶的跳法数
//f(n)：还剩n个台阶的跳法数
//
//状态递推：
//n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级
//跳1级，剩下n - 1级，则剩下跳法是f(n - 1)
//跳2级，剩下n - 2级，则剩下跳法是f(n - 2)
//f(n) = f(n - 1) + f(n - 2) + ... + f(n - n)
//f(n) = f(n - 1) + f(n - 2) + ... + f(0)
//f(n - 1) = f(n - 2) + ... + f(0)
//f(n) = 2 * f(n - 1)
//
//初始值：
//f(1) = 1
//f(2) = 2 * f(1) = 2
//f(3) = 2 * f(2) = 4
//f(4) = 2 * f(3) = 8
//所以它是一个等比数列
//f(n) = 2 ^ (n - 1)
//
//返回结果：f(N)

class Solution {
public:
    int jumpFloorII(int number) {
        if (number == 1) {
            return 1;
        }

        int f1 = 1;
        int f2 = 0;
        for (size_t i = 2; i <= number; ++i) {
            f2 = 2 * f1;
            f1 = f2;
        }
        return f2;
    }
};

//方法二：排列
//每个台阶看成一个位置，除过最后一个位置，其它位置都有两种可能性，
//所以总的排列数为2 ^ (n - 1) * 1 =2^(n-1)
class Solution {
public:
    int jumpFloorII(int number) {
        if (number <= 0)
            return 0;
        return 1 << (number - 1);
    }
};

//题目描述：矩形覆盖--我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？
// 数据范围：0 \le n \le 38 \0≤n≤38 进阶：空间复杂度 O(1)\O(1)  ，时间复杂度 O(n)\O(n) 注意：约定 n == 0 时，输出 0
//动态规划：
// 状态：
// 子状态：铺满2*1、2*2、2*3、...、2*n的大矩形的方法
// f(n):铺满2*n大矩形的方法
// 
// 状态递推：
// 铺满2*1的大矩形的方法f(1)只有一种方法
// 铺满2*2的大矩形的方法f(2)有俩种
// 铺满2*3的大矩形的方法f(3)有3种---f(3)=f(2)+f(1);
// ...
// 铺满2*n的大矩形的方法f(n)=f(n-1)+f(n-2)
//初始值：
//f(1)=1;f(2)=2;
class Solution {
public:
    int rectCover(int number) {
        if (number == 0) {
            return 0;
        }
        if (number == 1 || number == 2) {
            return number;
        }
        int f1 = 1;
        int f2 = 2;
        int f3 = 0;
        for (size_t i = 3; i <= number; ++i) {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }
};