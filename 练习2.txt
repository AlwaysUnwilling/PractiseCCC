int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = i;
		printf("%d ", *(p + i)/*arr[i]*/);
	}
	/*for (i = 0; i < 10; i++)
	{
		printf("%p ===================%p \n", p + i, &arr[i]);
	}*/
	return 0;
}

void exchange(int arr[], int arr1[], int sz)
{
	int i = 0;
	int tmp = 0;
	for (i = 0; i < sz; i++)
	{
		arr[i] = tmp;
		arr[i] = arr1[i];
		arr1[i] = tmp;
	}
}
int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int arr1[10] = { 99,98,97,96,95,94,93,92,91,90};
	exchange(arr, arr1, sz);
	printf("arr[10]= ");
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\narr1[10]= ");
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr1[i]);
	}
	printf("\n");
	return 0;
}
int count(int i)
{
	int j = 0;
	int count = 0;
	for (j = 0;j < 32;j++)
	{
		if (((i >>j)& 1 )==1)
		{
			count++;
		}
	}
	return count;
}
int main()
{
	int i = 15;
	int num = 0;
	num=count(i);
	printf("%d\n", num);
	return 0;
}
最优解-------》实现计算某个数字的二进制补码中数字1的个数；
int count(int a)
{
	int count = 0;
	while(a)
	{
		a = a & (a - 1);
		count++;
	}
	return count;
}
int main()
{
	int a = 0;
	scanf("%d", &a);
	int num = count(a);
	printf("num=%d\n", num);
	return 0;
}

int NUM(int a, int b)
{
	int i = 0;
	int count = 0;
	for (i = 0; i < 32; i++)
	{
		int c = a >> i & 1;
		int d = b >> i & 1;
		if (c != d)
		{
			count ++;
		}
	}
	return count;
}
int main()
{
	//int a = 1999;
	//int b = 2299;
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	int num = NUM(a, b);
	printf("%d\n", num);
	return 0;
}


int NUM(int a, int b)
{
	int count = 0;
	int c = a ^ b;
	while (c)
	{
		c=c& (c - 1);
		count++;
	}
	return count;
}
int main()
{
	//int a = 1999;
	//int b = 2299;
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	int num = NUM(a, b);
	printf("num=%d\n", num);
	return 0;
}
